##相关知识点总结
***
###正则表达式
---
* PHP中的正则表达式包含两种：
 + PCRE(Perl Compatible Regular Expression)，其函数以preg为前缀，为兼容Perl的正则表达式库
 + POSIX提供的函数，以ereg为前缀，PHP5.3后不再推荐使用，使用ereg系列函数会报有Deprecated级别错误
* PHP中的正则表达式包含三个部分：
 + 分隔符：除了字母、数字、反斜线和空白字符以外的任何字符均可作为分隔符，常用的有正斜线(/)，hash符号(#)以及取反符号(~)
 + 表达式：由一些特殊字符组成的字符串，用于进行字符串匹配
 + 修饰符：用于开启或者关系某种功能/模式
  
###元字符(Meta-Characters)
---
* 一般的英文字符会导致完全匹配
* 元字符包含的内容如下（不完整）
 + . 匹配除换行符以外的任意字符
 + \w 匹配字母或数字或下划线或汉字
 + \W [^\w]
 + \s 匹配任意空白符
 + \S [^\s]
 + \d 匹配数字，[0-9]
 + \D [^\d], [^0-9]
 + \b 匹配单词的开始或结束
 + \B [^\b]
 + ^ 字符串的开始
 + $ 字符串的结束
 + - 表示范围
 + [] 字符组，匹配其中任意一个
 + () 组，在组中^$表行首行尾
 + * 重复 >= 0次
 + + 重复 >= 1次
 + ? 重复 <= 1次
 + {n} 重复n次
 + {n,} 重复n次或更多次
 + {n,m} 重复n到m次
  
###正则表达式匹配规则
---
* 转义
 + 使用\进行转义；也可以使用\Q\E，其间的字符不被认为是元字符，而被视为普通字符  
   例：\(?0\d{2,3}[)-]?\d{8}可以匹配几种电话号码
 + 字符组内的量词元字符无需转义，无法匹配的{},[],()也无需转义
* 反义
 + 一般字符的反义使用^，而已知元字符的反义使用大写，如\d的反义即为\D
 + 用在开始位置的^表示字符串起始，而用于反义的^只能出现在字符组中
 + 不要随意使用反义，因为反义会扩大匹配范围，正则中尽量使用精确的匹配模式
* 分支
 + 使用|进行分支匹配，例如(a|to)t可以匹配at和tot，字符组[]可以看做是单个字符的分支匹配
 + 字符组的效率高于|分支，单个字符匹配时应尽量选择字符组
 + (exp)会导致文本捕获，如果不需要捕获则使用(?:exp)
 + 匹配分支条件时，从左到右测试，当遇到满足分支时则停止，故子分支需要放在较前的位置
* 分组
 + ()即是组的概念，组也可以重复多次，并且组会导致文本捕获
 + 使用组捕获的文本会被自动标记在对应的分组号中，从1开始依次增加
 + 可以使用(?<name>exp)或(?`name`exp)使当前组拥有自定义的组号
 + 可以使用(?:exp)剥夺一个组的组号分配参与权，即当前组文本不会被捕获
 + 零宽断言：(?=exp)匹配exp前面的位置、(?<=exp)匹配exp后面的位置、(?!exp)匹配后面不是exp的位置、(?<!exp)匹配前面不是exp的位置
 + (?#comment)提供注释辅助阅读，不影响正则表达式
* 反向引用
 + 使用分组匹配的文本可以被反向引用
 + 未命名分组的引用使用\1、\2……，其中\1表示的是匹配到的文本，而非正则表达式本身
 + 自定义组号的分组引用使用\k<name>的方式，例如\b(?<Word>\w+)\b\s+\k<Word>\b的效果与\b(\w+)\b\s+\1\b的效果相同
 + 例如引号匹配需要一致性，可以使用如下方式匹配引号内的文本^(?<Quote>"|').*?\k<Quote>$
* 环视
 + 环视即断言匹配，断言匹配匹配一个事实，而非内容
 + (?=exp) 称为零宽度正预测先行断言，又称顺序肯定环视，断言自身出现位置的后面能匹配表达式exp
 + (?<=exp) 称为零宽度回顾后发断言，又称逆序肯定环视，断言自身出现位置的前面能匹配表达式exp
 + 例：匹配HTML内容中被标签\<p\>或\<a\>包裹的内容的表达式为 (?=<[p|a]>).*(?<=<\/\1>)
 + (?!exp) 称为零宽度负预测先行断言，又称顺序否定环视，断言自身出现位置的后面不能匹配表达式exp
 + (?<!exp) 称为零宽度回顾后发断言，又称逆序否定环视，断言自身出现位置的前面不能匹配表达式exp
 + 例：匹配不包含简单HTML标签的内容表达式为 (?<!<\w>).*(?!<\/\1>)
* 贪婪/惰性匹配
 + 在默认匹配中，*+{}等量词的匹配总会尽可能多的匹配字符，这称为贪婪匹配
 + 在量词的后面加上一个?表示惰性匹配，即尽可能少的匹配字符
 + 贪婪匹配在匹配成功后会记录位置，然后向后匹配直到失败时回溯，故效率较低，适时使用惰性匹配可以提升效率

###构造正则表达式
---
* 逻辑关系
 + 与：连续字符或者顺序(逆序)肯定环视都表现的是与的关系。例如abc、(?<=\<div\>).*(?=\</div\>)
 + 或：或是指在某些中可能不出现或出现多次的情况，字符组[]和分组()内的|以及量词都是典型的或关系。例如匹配foot和feet可以用f(oo|ee)t或者f[oe]{2}t
 + 非：PCRE中非的关系表现为3中，一种是对于元字符，\d的非即为\D；一种是^在字符组中表示排除型否定；另外顺序(逆序)否定环视也是非的关系。例如匹配a标签可以用<a[^>]*>.*?<\/a>，这里使用了惰性匹配避免标签嵌套导致的问题，也可以用\<a[^\>]*\>([^\<\>]*)\</a\>
* 运算符优先级(从高到低)
 + \ 转义
 + [],(),(?:),(?=) 字符组、分组、环视
 + *,+,?,{n},{n,},{n,m} 量词
 + ^,$,\metacharacter,character 定位符、元字符、字符
 + | 或
* 模式修饰符(仅支持PCRE，不支持POSIX)
 + i 忽略大小写模式。会影响正则效率。在分隔符后跟i对整个表达式起效，如果使用(?i)则对其后面的一个字符起效
 + m 多行匹配模式。TODO 不是很理解
 + s 点号通配模式。启用该模式点号可以匹配换行符
 + U 懒惰模式。该模式相当于在量词后使用?，作用域为整个表达式
 + D 结尾限制。使用$时会忽视结尾的换行符，使用该模式可以强制限制结尾不能包含换行符
 + u 支持UTF-8转义表达。使PHP的正则表达可以支持UTF-8编码格式
  
###实际应用示例
---
* 移动手机号校验
 + 国内无区号简单校验：1[3578]/d{9}
 + 可能带中国区号的手机号校验：+{0,1}0{0,1}86\1[/s-]*1[3578]/d{9}，最复杂可以匹配如+(086)-13812345678的手机号
* E-mail地址校验
 + 基本匹配：\w{3,16}@\w{1,64}\.\w{2,5}，无法匹配.com.cn这种后缀地址
 + 完整匹配：^[a-z0-9_\-]+(\.[_a-z0-9\-]+)*@([_a-z0-9\-]+\.)+([a-z]{2}|aero|arpa|biz|com|coop|edu|gov|info|int|jobs|mil|museum|name|nato|net|org|pro|travel)$
* 转义在数据安全中的应用
 + 对于用户提交的内容，若含有CSS或者JS代码，不作处理输出可能导致页面篡改，称为XSS攻击。
 + 可以使用html-specialchars函数将HTML标签转换为HTML实体，这样输出不会受到影响。
 + 当然也可以使用正则表达式过滤提交内容中的HTML标签，使用如下表达式</?[^>]+>
 + PHP已经实现了函数strip_tags用于过滤标签，该函数使用白名单，会保留一些较为安全的HTML标签
 + 另外很多时候如SQL解析时需要进行字符串转义，可以使用addslashes函数为字符串添加转义反斜线
* URL重写与搜索引擎优化
 + Apache的Rewrite Engine也使用了PCRE正则表达式重写。此部分将单独有文章介绍。
 + 重写不仅仅可以美化URL，提高用户友好度，隐藏实现细节。重要的应用是将文件下载重定向到一个PHP文件来处理，这样权限判断、服务器分流等均可实现。
* 删除文件中的空行与注释
 + 使用^[\s]*$可以匹配空行
 + 使用//?*$可以匹配注释行

###正则表达式的优化策略
---
* 用字符组代替分支条件
 + 例如用[a-d]代替(a|b|c|d)，在性能上有质的差别，字符组内字符数越多，性能差距越大
* 优先选择最左端的匹配结果，即惰性匹配，性能优于贪婪匹配
* 标准量词是匹配优先的，即是贪婪匹配，故使用固定分组匹配有利于精确匹配
* 对于字符，能够缩小范围就不用使用“.”。对于量词，能够给出范围就不要使用“*”和“+”
* 可以使用字符串处理函数就不用正则表达式，效率有质的差别
* 善用()，()会捕获字符，一定要使用而无需捕获时一定要使用(?:exp)以节省内存空间
* PHP中还有大量函数可以处理特定的字符输入，如Tokenizer可以处理PHP源码，parse_url可以处理URL，get_headers可以处理HTTP头，filter_var可以进行参数校验等，在Javascript可以使用DOM模型来代替正则表达式
