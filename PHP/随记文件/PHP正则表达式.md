http://blog.csdn.net/e421083458/article/details/7924959
#字符
\s      匹配任意空字符（包括制表符、空格、换页）
\S      匹配任何非空字符
\f      匹配一个换页符
\r      匹配一个回车符
\d 
\w
\W
\t 制表符
\v 垂直制表符

()标记一个子表达式的开始和结束
.   匹配任何非换行符
[] 中括号表达式
{} 大括号表达式

#限定符
* + ? {} [] 
* + ?都是贪婪的，会尽可能的匹配多的文字，
加上?禁止贪婪

\b描述单词的前后边界，\B表示非单词边界

#选择 
()所有选择项括起来，相邻的选择项
之间用|，且相关的匹配会被缓存

非捕获元：
?:
?=
?!

#后向引用
存储子匹配的缓冲区编号从1开始，
连续编号直至最大99个子表达式，每个缓冲器都可以使用\n（n=1-99）
访问
可以使用?: ?! ?=来忽略对相关匹配的保存

#操作符优先级
\ 转义符
() (?:) (?=) [] () 
* + ? {} 限定符
^ $ 位置和顺序
| 或操作符

要匹配\n在内的任何字符，可以使用[.\n]
(?:pattern)匹配pattern但不获取匹配结果,也就是说这是一个非获取匹配,不进行存储供以后使用。
(?=pattern)正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
(?!pattern) 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
x|y 匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。
\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。
当在一组方括号里使用^是，它表示“非”或“排除”的意思，常常用来剔除某个字符。

#模式修正符
i    不区分大小写
m    多行匹配
s    使得.匹配所有字符，包括换行符

在中括号里面, 所有的特殊字符，包括(), 都将失去他们的特殊性质(i.e., "[*\+?{}.]"匹配含有这些字符的字符串)
[.]仅匹配.





构造检查emil：/^[_\w-]+[\.(\w_-)+]*@(\w+\.)*+(com|cn|org|info|net)$/


#PHP正则函数:
preg_match()
如果有匹配，则函数 preg_match() 返回 1。如果未找到匹配，则 preg_match() 返回零
如果在处理过程中出错，则函数将返回 False。


preg_match_all()
preg_replace();
preg_replace_all()
preg_grep()
preg_split()
preg_split() 第一个参数是模式，第二个参数是带匹配的字符串，第三个参数和第四个参数都是可选的，但是每个参数都十分有用。给第三个参数提供整数 n 将只返回前 n 个匹配；或者提供 -1 返回所有匹配。如果指定第四个参数，标志 PREG_SPLIT_NO_EMPTY、preg_split() 将处理所有空结果。
preg_last_error()
preg_quote()

IBM开发者文档
https://www.ibm.com/developerworks/cn/opensource/os-php-regex1/
#掌握PHP中的正则表达式，第一部分

###捕捉：()

preg_match()
如果提供一个变量作为 preg_match() 的第三个参数，例如这里的 $matches，则它被设为捕捉结果列表。第 0 个元素（索引编号为 0）是整个匹配；第 1 个元素是分别与第一组括号相关联的匹配，以此类推。
$address = "123 Main, Warsaw, NC, 29876";

$valid = "/((\d+)\s+(\w+)),\s+(\w+),\s+([A-Z]{2}),\s+(\d{5})/";

if ( preg_match( $valid, $address, $matches ) == 1 ) {
    echo(  "Street: ${matches[1]}<br />" );
    echo(  "Street number: ${matches[2]}<br />" );
    echo(  "Street name: ${matches[3]}<br />" );
    echo(  "City: ${matches[4]}<br />" );
    echo(  "State: ${matches[5]}<br />" );
    echo(  "Zip: ${matches[6]}<br />" );
}

###preg_replace()
 函数可以对单个字符串或字符串数组进行操作。如果对一个字符串数组而不是一个字符串调用 preg_replace()，则数组中的所有元素都将进行替换。在本例中，preg_replace() 将返回修改后的字符串数组。

#掌握PHP中的正则表达式，第二部分  处理文本

子模式限定符 ?: 将禁用捕捉
regex ((?i)edu)：如果子模式以修饰词 (?i) 为开头，则在子模式中进行匹配不区分大小写。只要子模式结束，区分大小写将被重新启用

另一个有用的子模式修饰词是 (?x)。它允许您在子模式中嵌入空白，使 regex 更易读。因而，子模式 ((?x) edu | com | info)（请注意备用操作符之间的空格，这些空格是为了易读性而添加的）与 (edu|com|info) 相同。您可以使用全局修饰词 /.../x 在整个 regex 中嵌入空白和注释

另外，如果需要在使用 (?x) 时匹配空格，那么，使用元字符 \s 来匹配所有空格字符或使用 \ （反斜杠后接空格）来匹配单个空格，如 ((?x) hello \ there)

如果输入跨度多行，则使用典型的 regex 是不够的，因为扫描将在 $ 所指示的换行符处终止。



































