<html><head><title>ProfileViewer</title></head><body bgcolor=white><div align=center><H1>ProfileViewer</H1><p>by Ulf Dittmer and Greg White</div><p>This Java application reads profiling information produced by the Javainterpreter and various flavours of the gprof tool and displays it for easy interpretation.<P>ProfileViewer was originally written by Greg White.Now that he no longer maintains it, he has released the sourceunder the GNU General Public License. This page describes the changes thathave been made since then; please do not contact Greg about this version.<BR><P>These instructions accompany version 1.0 of ProfileViewer.See the COPYING file for copyright and license information.<P><b>Requirements: </b>Java 1.4 or later<p>Although PV was conceived to handle the profiling output of Java 1, it works fine with theoutput generated by Java 2 if the "-prof" option is used (instead of the "-Xrunhprof" option,which generates Java 2 profiling output.)<BR>For Java 2 either the "-Xrunhprof:cpu=old" or the "-classic -prof" switch can be used,neither of which worked without hiccups for me, but your mileage may vary.<BR>I have no plans to add support for the Java 2 format to PV; the file format isvery different. I'd be happy to integrate it if someone wants to take a shot at it, though. Thanks to enhancements by Luc Maisonobe, several differentprofiling formats can be recognized and read by PV.<HR><b>Download</b><P><em>Latest version 1.0.3 released <a href="changes.html#6_16_09">June 16, 2009</a></em><p>This <a href="ProfileViewer-1.0.3.zip">Zip file</a> contains the source files, the executablejar file and the documentation.<P><HR><BR>If you're using ProfileViewer, you might also be interested in Nathan Fiedlers <a href="http://bluemarsh.com/java/jswat/">JSwat</a>, a GPL'ed Java debuggerbased on Suns JPDA debugging architecture. Especially interesting is its ability to attachto a running JVM, and to debug on remote hosts.<hr><h2>Table of Contents</h2><ul><li><a HREF="#installing">Installing ProfileViewer</a></li><li><a HREF="#creating profile">Creating a Profile File</a></li><li><a HREF="#starting">Starting ProfileViewer</a></li><li><a HREF="#windows">The Screen</a></li><li><a HREF="menus.html">Menu Reference</a></li><ul><li><a HREF="menus.html#ref profile">Profile Menu</a></li><li><a HREF="menus.html#ref method">Method Menu</a></li><li><a HREF="menus.html#ref options">Options Menu</a></li></ul><li><a HREF="#usage">General Usage Notes</a></li><li><a HREF="#work needed">Some Known Problems</a></li><li><a HREF="#other formats">Other Profile Formats</a></li><ul><li><a HREF="#fmt supported">Supported formats</a></li><li><a HREF="#fmt gprof">Working with gprof profiles</a></li><li><a HREF="#fmt adding">Adding a Format</a></li></ul><li><a HREF="changes.html">Revisions</a></li></ul><hr><h2><a name="installing">Installing ProfileViewer</a></h2><h3>Unzip ProfileViewer.zip</h3>Unzip the distribution into a directory of your choice.<h3>Modify <a name="classpath">CLASSPATH</a></h3>Add the jar files to the classpath environment variable.Alternatively, just double-click the ProfileViewer jar file.<hr><h2><a name="creating profile">Creating a Profile File</a></h2>You create a profile file for an application by running the java interpreterwith the <CODE>-prof</CODE> option (e.g. <code>java -prof MyApp</code>).<p>The procedure for creating a profile file for an applet is similar. Type<p><code>java -prof sun.applet.AppletViewer</code> <em>app.html</em><p>where <em>app.html</em> is the HTML file you normally pass to the applet viewer.When profiling applets, you may find that there is much more profilinginformation than you really want due to all of the supporting classes.<P><a name="programmatically">Here's some info about using the <code>sun.misc.VM</code> class to get more controlover when profiling data is generated or written to disk.It's quoted verbatim from a post by Jens Alfke to the mrj-dev list.<i>Note: This class seems to have changed quite a bit since I last used it in theJava 1.1 days. JDKs 1.3 and later do no longer have these methods,and I don't know where this functionality might be located now. Of course,the sun.* hierarchy is subject to change without notice, so this was to be expected.</i><P><PRE>What's less known is that you can drive the profiler yourself, and have it run only on the parts of your code you're interested in. (This also helps avoid buffer overflows with very large apps.) To do this, *don't* turn on profiling from JBindery. Instead, import the class "sun.misc.VM" and use the following static methods:    /** Starts/resumes profiling */    public static void resumeJavaMonitor();    /** Stops profiling */    public static void suspendJavaMonitor();    /** Clears profile data */    public static void resetJavaMonitor();    /** Dumps profile data to "java.prof" (overwriting) */    public static void writeJavaMonitorReport();Your code might look like this:    import sun.misc.VM;    ...    VM.resumeJavaMonitor();    this.verySlowOperation();   // what you're profiling    VM.suspendJavaMonitor();    VM.writeJavaMonitorReport();Note that you have to write the report manually; it won't be written automatically at quit if you didn't activate profiling in JBindery. Also note that if you try to write multiple reports, each will overwrite the last (unless you get tricky and use File.rename to rename the old one...)</PRE><hr><h2><a name="starting">Starting ProfileViewer</a></h2>To start ProfileViewer, type:<p><code>java ProfileViewer</code> <em>Profile</em><p>where <em>Profile</em> optionally specifies the name of a profile file toload. If this parameter is not specified, ProfileViewer will start withoutloading a file. This assumes all jar files are in your classpath. Alternatively, Windows users can simply double-click the "runit.bat" file.<P>It is also possible to double-click the ProfileViewer Jar file.<hr><h2><a name="windows">The Screen</a></h2>The main screen consists of three lists and a status line. The list to theleft shows all methods known. The list to the upper right shows allcallees (methods called by the currently selected method in the list to theleft). The list to the lower right shows all callers (methods calling thecurrently selected method in the list to the left).<p>The format of each line in these lists is<pre>time calls method</pre>where time and calls are shown as percentages by default, but they can bechanged to show absolute values (time in milliseconds and calls by count).<p>All percentages are relative to the lifetime of the application. In themethods list, the percentage is an overall value for each method. In thecallees list, percentages shown reflect calls made to each method from theselected method to the left. In thecallers list, percentages shown reflect calls made from each method to theselected method to the left.<p>When showing absolute values, the methods list entries are totals for eachmethod while in the callees and callers list,these numbers are only in relation to the selected method in the list on the left.<p>The status line at the bottom shows the full name of the currently selectedmethod. This helps you to see names that might be too long otherwise.<p>Entries of the form <code>"...&lt;init&gt;"</code> indicate the constructorof the respective class, those of the form <code>"...&lt;clinit&gt;"</code>static initializers of the class.<hr><h2><a name="usage">General Usage Notes</a></h2><h3>Caveat</h3>The information shown here is only as good as the information produced by thejava interpreter. In some cases (especially recursion), the results don'tseem to make any sense at all. If someone has pointers to betterdocumentation about the profile information, I will be glad to includeinformation here or change ProfileViewer to accommodate it.<p>Also note that Sun's documentation for javaprof (a text-based report tool forthe profile file) says it will not work correctly for multi-threadedapplications. I expect that this warning ought to be for the profile fileitself, not just for javaprof.<h3>Optimizing Your Program</h3>See <a href="http://www.cs.cmu.edu/~jch/java/optimization.html">Java Optimization</a>by Jonathan Hardwick for some excellent reading about optimization and Java.Unfortunately, it is no longer maintained.<p><hr><h2><a name="work needed">Some Known Problems</a></h2>If you have solutions or workarounds for these, please let me know.<h3>Can't set the width of the split panes in the main window</h3>The JSplitPane.setDividerLocation method should do that, but there's a registered bug in Swing 1.1 that prevents that from working.The dividers are movable, though, so this shouldn't be a big problem.<h3>Windows JDK 1.3: Exclude dialog doesn't pick up the item in the last row</h3>Workaround is to manually select another row or field before clicking "OK".This doesn't happen uder JDK 1.1/Swing 1.1.1. I don't know about JDK 1.2.<hr><h2><a name="other formats">Other Profile Formats</a></h2><h3><a name="fmt supported">Supported formats</a></h3>As of version 1.0, ProfileViewer has been extended to support someother profile file formats. The supported formats are:<ul><li>Classic java profile format<br>This format is the Java 1.x profiling output format; later JVM versions can also create output in this format.</li><li>GNU gprof profile format<br>This format is generated by the GNU version of the <code>gprof</code>utility. Gprof can convert the binary output generated while runningprograms compiled by a C, C++, pascal or fortran compiler with the<code>-pg</code> profiling flag into a text format.</li><li>Solaris gprof profile format<br>This format is generated by the Solaris version of the <code>gprof</code>utility. Gprof can convert the binary output generated while runningprograms compiled by a C, C++, pascal or fortran compiler with the<code>-pg</code> profiling flag into a text format.</li><li>OS X gprof profile format<br>I'm not sure whether this version is closer to the GNU or Solaris versions,but it's invoked in the same way using the <code>-pg</code> flag.</li></ul>These formats are recognized automatically on loading.<h3><a name="fmt gprof">Working with gprof profiles</a></h3>Here's a brief rundown on how to obtain and use gprof profiles for native code(like C/C++/Fortran77/Pascal). If you have a test.c file containing the application, ...<ul><li>Compile it using the "-pg" option:<BR><code>gcc -pg test.c</code><BR>This should create the file a.out.<li>Run it:<br><code>./a.out</code><br>This should create the file gmon.out.<li>Run gprof to create the profile file:<br><code>gprof -b -z a.out &gt; results.txt</code><br>This should create the file results.txt.<li>Run ProfileViewer with results.txt as input:<br><code>java -jar ProfileViewer-1.0.3.jar results.txt</code></ul>If you run into problems where ProfileViewer doesn't recognize the file format,or omits some methods that should be there, check the command line optionswith which gprof is run. In particular, the "-b" and "-z" options should be set.<h3><a name="fmt adding">Adding a Format</a></h3>Adding support for a new profiler output format is quite simple.<p>The first step is to create your own parser as a class implementingthe <code>ProfileParser</code> interface. This interface is limited tothree methods: <code>nextInvocationLine</code>,<code>stopParsing</code> and <code>getLineNo</code>. The easiest wayto do this is to start from the existing classes(<code>ClassicJavaProfileParser</code> and<code>[Abstract|GNU|OSX|Solaris]GprofProfileParser</code>).</p><p>The second step is to register your class in the parser factorymethod <code>ProfileParserFactory.buildParser</code>. This step ismerely adding a two lines test in an existing <code>if</code> statement.</p><HR><a href="../index.html"><b>Back To Main Page</b></a></body></html>